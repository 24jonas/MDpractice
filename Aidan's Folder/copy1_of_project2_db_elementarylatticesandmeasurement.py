# -*- coding: utf-8 -*-
"""Copy1 of project2-db-elementarylatticesandmeasurement.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nssoWbPG3tS9SOstjKABSaXjCytpn8Bg
"""

#@title 1. Installs for collab

#@title 2. Imports
import os
import sys

#Required installs: Numpy, ASE, GPAW paralelized, flatgraphene, SciPy
import numpy as np

import ase
from ase import Atoms
from ase.parallel import parprint
from ase.dft.kpoints import bandpath
from ase.dft.kpoints import get_special_points
from ase.spectrum.band_structure import get_band_structure, BandStructure
from ase.visualize import view
from gpaw import GPAW, FermiDirac, PW
from gpaw.lcao.tools import get_lcao_hamiltonian

import ase.units as units
from gpaw.utilities.tools import tri2full
import scipy.linalg as sla

import matplotlib.pyplot as plt

from gpaw import GPAW, PW, FermiDirac

"""# **3b Silver**"""

# Diamond primitive cell
a = 3.567
supercell = np.zeros((3,3)) # NUM VEC, DIM

# Cell vectors
supercell[0] = (a/2)*np.array([1,1,0])
supercell[1] = (a/2)*np.array([1,0,1])
supercell[2] = (a/2)*np.array([0,1,1])

positions = np.zeros((2,3)) # Num Particle, Dim

positions[0] = 0*supercell[0] + 0*supercell[1] + 0*supercell[2] # Set positions of particles in the cell (basis)
positions[1] = 0.25 * supercell[0] + 0.25 * supercell[1] + 0.25 * supercell[2]

diamond = ase.Atoms('C2', positions, cell=supercell, pbc=True)

#Visualize
ase.visualize.view(diamond)
view(diamond, viewer='x3d')

# Manual parallel and more approximated band structure (good for bigger cells), manual cell and kpoints
band_parallelization = 1
nKpoints = 16
nBands = 8
basisN = 9 # 4 for carbon or Si sz(dzp), 9 for carbon or Si szp(dzp), 12 for Ag sz(dzp)
datapath = "data/"
Natoms = len(positions[:,0])

calc = GPAW(mode='lcao',
            basis='szp(dzp)',
            xc='PBE',
            kpts=(2, 2, 2),
            occupations=FermiDirac(0.01),
            txt=datapath+'diamond.txt',
            parallel=dict(band=band_parallelization,              # band parallelization
                            augment_grids=True,  # use all cores for XC/Poisson
                            sl_auto=True)        # enable parallel ScaLAPACK
            )

diamond.calc = calc
en1 = diamond.get_potential_energy()
calc.write(datapath+'diamond.gpw')


# Compute band path with a sequential approach, one kpt at a time, to use less memory.
points = ["W","L","G","X","W","K"]
path = bandpath(points, supercell, nKpoints) #They are in basis of recip vec, should multiply by recips
kpts = path.kpts

# *4 is valence per atom, for sz basis carbon has 4
eps_kn = []
lcaoH = np.zeros((nKpoints,Natoms*basisN,Natoms*basisN), dtype="cdouble")
lcaoS = np.zeros((nKpoints,Natoms*basisN,Natoms*basisN), dtype="cdouble")


#parprint('Calculation on', len(kpts), 'k points:')
ref, energies = [], []
for i, k in enumerate(kpts):
    # Restart from ground state and fix potential:
    calc = GPAW(datapath+'diamond.gpw',
                fixdensity=True,
                kpts=[k],
                symmetry='off',
                txt=datapath+'graphene_bilayer_bs_.txt',
                parallel={'kpt':                 None,
                            'domain':              None,
                            'band':                1,
                            'order':               'kdb',
                            'stridebands':         False,
                            'augment_grids':       False,
                            'sl_auto':             False,
                            'sl_default':          None,
                            'sl_diagonalize':      None,
                            'sl_inverse_cholesky': None,
                            'sl_lcao':             None,
                            'sl_lrtddft':          None,
                            'use_elpa':            False,
                            'elpasolver':          '2stage',
                            'buffer_size':         None}        # enable parallel ScaLAPACK
                )

    diamond.calc = calc

    en2 = calc.get_potential_energy()

    #Manual electronic structure
    h = calc.hamiltonian
    wfs = calc.wfs
    kpt_u = wfs.kpt_u

    for kpt in kpt_u:
        H_MM = wfs.eigensolver.calculate_hamiltonian_matrix(h, wfs, kpt)
        S_MM = wfs.S_qMM[kpt.q]
        tri2full(H_MM)

    H_MM = np.array(H_MM)
    S_MM = np.array(S_MM)

    lcaoH[i,:,:] = H_MM
    lcaoS[i,:,:] = S_MM


#Getting bands
eps_kn = []
for i in range(0,nKpoints):
    eps_n, c_Mn = sla.eigh(lcaoH[i,:,:], lcaoS[i,:,:])
    c_nM = c_Mn[:, eps_n.argsort()].transpose()

    eps_n.sort()
    eps_kn.append(eps_n)

eps_kn = np.array(eps_kn)*ase.units.Hartree #Necessary if not using parallel dump H



#Plotting parameters
lowestBand = int(Natoms*2 - nBands/2)
hightestBand = int(Natoms*2 + nBands/2) ##Bands is Natoms*valence, to get half we do valence/2, C has valence 4

E = np.zeros((nBands,nKpoints))
index = np.zeros(nKpoints)
for i in range(0,nKpoints):
    index[i] = i
    print(index[i])

j=0
for i in range(lowestBand,hightestBand):
    E[j] = eps_kn[:,i]
    j=j+1

with open("E_band.npy", 'wb') as f:
    np.save(f, E)

#Export
Positions = diamond.get_positions()

with open("PosCalc.npy", 'wb') as f:
    np.save(f, Positions)

# Plot from saved file
E = np.load("E_band.npy")

ax = plt.gca()
ax.set_xlabel("K point")
ax.set_ylabel("Energy [eV]")
ax.set_ylim(-10, 20)
plt.grid()

for j in range(0,len(E)):
    plt.plot(index, E[j], '-m')

plt.show()